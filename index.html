<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relation Properties Visualizer</title>
    <style>
        :root {
            --primary-color: rgba(255, 255, 255, 0.15);
            --secondary-color: rgba(255, 255, 255, 0.1);
            --accent-color: rgba(86, 124, 228, 0.5);
            --text-color: #fff;
            --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            --border: 1px solid rgba(255, 255, 255, 0.18);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--text-color);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--primary-color);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: var(--shadow);
            border: var(--border);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: var(--primary-color);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: var(--shadow);
            border: var(--border);
            padding: 20px;
            flex: 1;
            min-width: 300px;
        }

        .card h2 {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .input-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: 500;
        }

        input, select, button {
            padding: 10px 15px;
            border-radius: 8px;
            border: none;
            background: var(--secondary-color);
            color: var(--text-color);
            backdrop-filter: blur(5px);
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        button {
            background: var(--accent-color);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
        }

        #graph-canvas {
            background: var(--secondary-color);
            border-radius: 10px;
            max-width: 100%;
        }

        .properties-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .property {
            padding: 15px;
            background: var(--secondary-color);
            border-radius: 10px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .property.true {
            background: rgba(76, 175, 80, 0.3);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .property.false {
            background: rgba(244, 67, 54, 0.3);
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
        }

        .property-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .property-value {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .matrix-container {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        th {
            background: var(--accent-color);
        }

        td {
            background: var(--secondary-color);
        }

        .highlight {
            background: rgba(255, 255, 0, 0.3) !important;
        }

        footer {
            text-align: center;
            padding: 20px;
            background: var(--primary-color);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: var(--shadow);
            border: var(--border);
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .properties-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Relation Properties Visualizer</h1>
            <p class="subtitle">A Visualization-Based Pedagogical Tool for Understanding Relations in Discrete Mathematics</p>
        </header>

        <div class="main-content">
            <div class="card input-section">
                <h2>Input Relation</h2>
                <div class="input-group">
                    <label for="set-input">Set Elements (comma separated):</label>
                    <input type="text" id="set-input" placeholder="e.g., 1,2,3" value="1,2,3">
                </div>
                <div class="input-group">
                    <label for="relation-input">Relation Pairs (comma separated pairs):</label>
                    <input type="text" id="relation-input" placeholder="e.g., (1,1),(1,2),(2,1)" value="(1,1),(1,2),(2,1),(2,2),(3,3)">
                </div>
                <div class="input-group">
                    <label for="example-select">Or select an example:</label>
                    <select id="example-select">
                        <option value="custom">Custom Relation</option>
                        <option value="reflexive">Reflexive Relation</option>
                        <option value="symmetric">Symmetric Relation</option>
                        <option value="transitive">Transitive Relation</option>
                        <option value="asymmetric">Asymmetric Relation</option>
                        <option value="equivalence">Equivalence Relation</option>
                    </select>
                </div>
                <button id="analyze-btn">Analyze Relation</button>
            </div>

            <div class="card">
                <h2>Visualization</h2>
                <div class="visualization">
                    <canvas id="graph-canvas" width="500" height="400"></canvas>
                </div>
            </div>

            <div class="card">
                <h2>Relation Properties</h2>
                <div class="properties-grid" id="properties-container">
                    <!-- Properties will be populated by JavaScript -->
                </div>
            </div>

            <div class="card">
                <h2>Relation Matrix</h2>
                <div class="matrix-container">
                    <table id="relation-matrix">
                        <!-- Matrix will be populated by JavaScript -->
                    </table>
                </div>
            </div>
        </div>

        <footer>
            <p>Educational Tool for Discrete Mathematics | Created for better understanding of relation properties</p>
        </footer>
    </div>

    <script>
        // DOM Elements
        const setInput = document.getElementById('set-input');
        const relationInput = document.getElementById('relation-input');
        const exampleSelect = document.getElementById('example-select');
        const analyzeBtn = document.getElementById('analyze-btn');
        const graphCanvas = document.getElementById('graph-canvas');
        const propertiesContainer = document.getElementById('properties-container');
        const relationMatrix = document.getElementById('relation-matrix');

        // Canvas context
        const ctx = graphCanvas.getContext('2d');

        // Relation analysis functions
        function parseSet(setStr) {
            return setStr.split(',').map(item => item.trim()).filter(item => item !== '');
        }

        function parseRelation(relationStr, set) {
            const pairs = [];
            const pairRegex = /\(([^,]+),([^)]+)\)/g;
            let match;
            
            while ((match = pairRegex.exec(relationStr)) !== null) {
                const a = match[1].trim();
                const b = match[2].trim();
                
                // Only add pairs where both elements are in the set
                if (set.includes(a) && set.includes(b)) {
                    pairs.push([a, b]);
                }
            }
            
            return pairs;
        }

        function isReflexive(relation, set) {
            for (const element of set) {
                let found = false;
                for (const [a, b] of relation) {
                    if (a === element && b === element) {
                        found = true;
                        break;
                    }
                }
                if (!found) return false;
            }
            return true;
        }

        function isIrreflexive(relation, set) {
            for (const element of set) {
                for (const [a, b] of relation) {
                    if (a === element && b === element) {
                        return false;
                    }
                }
            }
            return true;
        }

        function isSymmetric(relation) {
            for (const [a, b] of relation) {
                let found = false;
                for (const [x, y] of relation) {
                    if (x === b && y === a) {
                        found = true;
                        break;
                    }
                }
                if (!found) return false;
            }
            return true;
        }

        function isAntisymmetric(relation) {
            for (const [a, b] of relation) {
                if (a !== b) {
                    for (const [x, y] of relation) {
                        if (x === b && y === a) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function isAsymmetric(relation, set) {
            // Asymmetric means it is both antisymmetric and irreflexive
            return isAntisymmetric(relation) && isIrreflexive(relation, set);
        }

        function isTransitive(relation) {
            for (const [a, b] of relation) {
                for (const [x, y] of relation) {
                    if (b === x) {
                        let found = false;
                        for (const [p, q] of relation) {
                            if (p === a && q === y) {
                                found = true;
                                break;
                            }
                        }
                        if (!found) return false;
                    }
                }
            }
            return true;
        }

        function createRelationMatrix(relation, set) {
            const matrix = [];
            
            // Initialize matrix with zeros
            for (let i = 0; i < set.length; i++) {
                matrix[i] = [];
                for (let j = 0; j < set.length; j++) {
                    matrix[i][j] = 0;
                }
            }
            
            // Fill matrix based on relation
            for (const [a, b] of relation) {
                const i = set.indexOf(a);
                const j = set.indexOf(b);
                if (i !== -1 && j !== -1) {
                    matrix[i][j] = 1;
                }
            }
            
            return matrix;
        }

        function drawGraph(relation, set) {
            // Clear canvas
            ctx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
            
            // Set up drawing parameters
            const centerX = graphCanvas.width / 2;
            const centerY = graphCanvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.7;
            
            // Draw nodes
            const nodes = [];
            for (let i = 0; i < set.length; i++) {
                const angle = (2 * Math.PI * i) / set.length;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                nodes.push({x, y, label: set[i]});
                
                // Draw node circle
                ctx.beginPath();
                ctx.arc(x, y, 20, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(86, 124, 228, 0.7)';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw node label
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(set[i], x, y);
            }
            
            // Draw edges
            for (const [a, b] of relation) {
                const fromIndex = set.indexOf(a);
                const toIndex = set.indexOf(b);
                
                if (fromIndex !== -1 && toIndex !== -1) {
                    const fromNode = nodes[fromIndex];
                    const toNode = nodes[toIndex];
                    
                    // Self-loop
                    if (a === b) {
                        ctx.beginPath();
                        ctx.arc(fromNode.x, fromNode.y - 25, 15, 0, 2 * Math.PI);
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        continue;
                    }
                    
                    // Regular edge
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw arrowhead for directed edge
                    const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
                    const arrowLength = 10;
                    const arrowX = toNode.x - 20 * Math.cos(angle);
                    const arrowY = toNode.y - 20 * Math.sin(angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(arrowX, arrowY);
                    ctx.lineTo(
                        arrowX - arrowLength * Math.cos(angle - Math.PI / 6),
                        arrowY - arrowLength * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        arrowX - arrowLength * Math.cos(angle + Math.PI / 6),
                        arrowY - arrowLength * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fillStyle = 'white';
                    ctx.fill();
                }
            }
        }

        function updatePropertiesDisplay(relation, set) {
            propertiesContainer.innerHTML = '';
            
            const properties = [
                { name: 'Reflexive', value: isReflexive(relation, set) },
                { name: 'Irreflexive', value: isIrreflexive(relation, set) },
                { name: 'Symmetric', value: isSymmetric(relation) },
                { name: 'Antisymmetric', value: isAntisymmetric(relation) },
                { name: 'Asymmetric', value: isAsymmetric(relation, set) },
                { name: 'Transitive', value: isTransitive(relation) },
                { name: 'Equivalence', value: isReflexive(relation, set) && isSymmetric(relation) && isTransitive(relation) }
            ];
            
            properties.forEach(prop => {
                const propertyEl = document.createElement('div');
                propertyEl.className = `property ${prop.value ? 'true' : 'false'}`;
                
                propertyEl.innerHTML = `
                    <div class="property-name">${prop.name}</div>
                    <div class="property-value">${prop.value ? '✓' : 'X'}</div>
                `;
                
                propertiesContainer.appendChild(propertyEl);
            });
        }

        function updateMatrixDisplay(matrix, set) {
            relationMatrix.innerHTML = '';
            
            // Create header row
            let headerRow = '<tr><th></th>';
            set.forEach(element => {
                headerRow += `<th>${element}</th>`;
            });
            headerRow += '</tr>';
            relationMatrix.innerHTML += headerRow;
            
            // Create data rows
            for (let i = 0; i < set.length; i++) {
                let row = `<tr><th>${set[i]}</th>`;
                for (let j = 0; j < set.length; j++) {
                    const cellClass = matrix[i][j] === 1 ? 'highlight' : '';
                    row += `<td class="${cellClass}">${matrix[i][j]}</td>`;
                }
                row += '</tr>';
                relationMatrix.innerHTML += row;
            }
        }

        function analyzeRelation() {
            const set = parseSet(setInput.value);
            const relation = parseRelation(relationInput.value, set);
            
            if (set.length === 0) {
                alert('Please enter valid set elements');
                return;
            }
            
            if (relation.length === 0) {
                alert('Please enter valid relation pairs');
                return;
            }
            
            // Update visualization
            drawGraph(relation, set);
            
            // Update properties display
            updatePropertiesDisplay(relation, set);
            
            // Update matrix display
            const matrix = createRelationMatrix(relation, set);
            updateMatrixDisplay(matrix, set);
        }

        function loadExample() {
            const example = exampleSelect.value;
            const examples = {
                reflexive: {
                    set: '1,2,3,4',
                    relation: '(1,1),(2,2),(3,3),(4,4)'
                },
                symmetric: {
                    set: '1,2,3,4',
                    relation: '(1,2),(2,1),(3,4),(4,3)'
                },
                transitive: {
                    set: '1,2,3,4',
                    relation: '(1,2),(2,3),(1,3),(4,4)'
                },
                asymmetric: {
                    set: '1,2,3,4',
                    relation: '(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)'
                },
                equivalence: {
                    set: '1,2,3,4',
                    relation: '(1,1),(2,2),(3,3),(4,4),(1,2),(2,1),(3,4),(4,3)'
                }
            };
            
            if (example !== 'custom' && examples[example]) {
                setInput.value = examples[example].set;
                relationInput.value = examples[example].relation;
                analyzeRelation();
            }
        }

        // Event listeners
        analyzeBtn.addEventListener('click', analyzeRelation);
        exampleSelect.addEventListener('change', loadExample);

        // Initialize with default example
        window.addEventListener('load', () => {
            analyzeRelation();
        });
    </script>
</body>
</html>