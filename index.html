<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relation Properties Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #6b8cbc;
            --accent: #ff6b6b;
            --light: #f8f9fa;
            --dark: #343a40;
            --success: #51cf66;
            --warning: #ffd43b;
            --danger: #ff6b6b;
            --info: #339af0;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: var(--dark);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }
        
        .card-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: var(--primary);
            border-bottom: 2px solid var(--light);
            padding-bottom: 10px;
        }
        
        .input-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .set-input, .relation-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .btn {
            padding: 12px 20px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: var(--secondary);
        }
        
        .properties-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        
        @media (max-width: 1200px) {
            .properties-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 600px) {
            .properties-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .property {
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 80px;
        }
        
        .property.true {
            background-color: rgba(81, 207, 102, 0.2);
            color: var(--success);
            border: 2px solid var(--success);
        }
        
        .property.false {
            background-color: rgba(255, 107, 107, 0.2);
            color: var(--danger);
            border: 2px solid var(--danger);
        }
        
        .property.na {
            background-color: rgba(255, 212, 59, 0.2);
            color: var(--warning);
            border: 2px solid var(--warning);
        }
        
        .property.partial {
            background-color: rgba(51, 154, 240, 0.2);
            color: var(--info);
            border: 2px solid var(--info);
        }
        
        .visualization-container {
            width: 100%;
            height: 500px;
            background-color: var(--light);
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
            position: relative;
        }
        
        #relation-graph {
            width: 100%;
            height: 100%;
        }
        
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9f5ff;
            border-radius: 8px;
            border-left: 4px solid var(--primary);
        }
        
        .examples {
            margin-top: 30px;
        }
        
        .example-btn {
            margin-right: 10px;
            margin-bottom: 10px;
            padding: 8px 15px;
            background-color: var(--light);
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .example-btn:hover {
            background-color: #e2e6ea;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        .matrix {
            display: grid;
            gap: 2px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .matrix-cell {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            border: 1px solid #ddd;
            font-weight: bold;
        }
        
        .matrix-cell.active {
            background-color: var(--primary);
            color: white;
        }
        
        .matrix-header {
            font-weight: bold;
            text-align: center;
        }
        
        .property-name {
            font-size: 1rem;
            margin-bottom: 5px;
        }
        
        .property-status {
            font-size: 0.9rem;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Relation Properties Visualizer</h1>
            <p class="subtitle">A Visualization-Based Pedagogical Tool for Understanding Relations in Discrete Mathematics</p>
        </header>
        
        <div class="main-content">
            <div class="input-column">
                <div class="card">
                    <h2 class="card-title">Input Relation</h2>
                    <div class="input-section">
                        <label for="set-input">Set Elements (comma separated):</label>
                        <input type="text" id="set-input" class="set-input" placeholder="e.g., 1,2,3,4">
                        
                        <label for="relation-input">Relation (comma separated pairs):</label>
                        <input type="text" id="relation-input" class="relation-input" placeholder="e.g., (1,1),(1,2),(2,1)">
                        
                        <button id="analyze-btn" class="btn">Analyze Relation</button>
                    </div>
                    
                    <div class="examples">
                        <h3>Example Relations:</h3>
                        <button class="example-btn" data-set="1,2,3" data-relation="(1,1),(2,2),(3,3)">Reflexive</button>
                        <button class="example-btn" data-set="1,2,3" data-relation="(1,2),(2,1),(2,3),(3,2)">Symmetric</button>
                        <button class="example-btn" data-set="1,2,3" data-relation="(1,2),(2,3),(1,3)">Transitive</button>
                        <button class="example-btn" data-set="1,2,3" data-relation="(1,2),(2,3)">Asymmetric</button>
                        <button class="example-btn" data-set="1,2,3" data-relation="(1,1),(2,2),(3,3),(1,2),(2,1)">Equivalence</button>
                        <button class="example-btn" data-set="1,2,3,4" data-relation="(1,2),(2,3),(3,4),(1,3),(1,4),(2,4)">Complex</button>
                    </div>
                </div>
                
                <div class="card">
                    <h2 class="card-title">Relation Matrix</h2>
                    <div id="matrix-container"></div>
                </div>
            </div>
            
            <div class="results-column">
                <div class="card">
                    <h2 class="card-title">Properties</h2>
                    <div class="properties-grid">
                        <div id="reflexive" class="property">
                            <div class="property-name">Reflexive</div>
                            <div class="property-status">Checking...</div>
                        </div>
                        <div id="irreflexive" class="property">
                            <div class="property-name">Irreflexive</div>
                            <div class="property-status">Checking...</div>
                        </div>
                        <div id="symmetric" class="property">
                            <div class="property-name">Symmetric</div>
                            <div class="property-status">Checking...</div>
                        </div>
                        <div id="antisymmetric" class="property">
                            <div class="property-name">Antisymmetric</div>
                            <div class="property-status">Checking...</div>
                        </div>
                        <div id="asymmetric" class="property">
                            <div class="property-name">Asymmetric</div>
                            <div class="property-status">Checking...</div>
                        </div>
                        <div id="transitive" class="property">
                            <div class="property-name">Transitive</div>
                            <div class="property-status">Checking...</div>
                        </div>
                        <div id="equivalence" class="property">
                            <div class="property-name">Equivalence</div>
                            <div class="property-status">Checking...</div>
                        </div>
                    </div>
                    
                    <div class="explanation">
                        <h3>Explanation</h3>
                        <p id="property-explanation">Enter a set and relation to see property explanations.</p>
                    </div>
                </div>
                
                <div class="card">
                    <h2 class="card-title">Visualization</h2>
                    <div class="visualization-container">
                        <canvas id="relation-graph"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
    
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const setInput = document.getElementById('set-input');
            const relationInput = document.getElementById('relation-input');
            const analyzeBtn = document.getElementById('analyze-btn');
            const matrixContainer = document.getElementById('matrix-container');
            const propertyExplanation = document.getElementById('property-explanation');
            const exampleBtns = document.querySelectorAll('.example-btn');
            const graphCanvas = document.getElementById('relation-graph');
            
            // Property elements
            const reflexiveEl = document.getElementById('reflexive');
            const irreflexiveEl = document.getElementById('irreflexive');
            const symmetricEl = document.getElementById('symmetric');
            const antisymmetricEl = document.getElementById('antisymmetric');
            const asymmetricEl = document.getElementById('asymmetric');
            const transitiveEl = document.getElementById('transitive');
            const equivalenceEl = document.getElementById('equivalence');
            
            let currentSet = [];
            let currentRelation = [];
            let graphChart = null;
            
            // Initialize with an example
            setInput.value = "1,2,3";
            relationInput.value = "(1,1),(1,2),(2,1),(2,2),(3,3)";
            analyzeRelation();
            
            // Event listeners
            analyzeBtn.addEventListener('click', analyzeRelation);
            
            exampleBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    setInput.value = this.getAttribute('data-set');
                    relationInput.value = this.getAttribute('data-relation');
                    analyzeRelation();
                });
            });
            
            function analyzeRelation() {
                // Parse set and relation
                currentSet = parseSet(setInput.value);
                currentRelation = parseRelation(relationInput.value);
                
                // Validate inputs
                if (currentSet.length === 0) {
                    alert("Please enter a valid set with at least one element.");
                    return;
                }
                
                // Check if all relation elements are in the set
                for (const pair of currentRelation) {
                    if (!currentSet.includes(pair[0]) || !currentSet.includes(pair[1])) {
                        alert(`The pair (${pair[0]},${pair[1]}) contains elements not in the set.`);
                        return;
                    }
                }
                
                // Update visualization and properties
                updateMatrix();
                updateProperties();
                updateGraph();
                updateExplanation();
            }
            
            function parseSet(setStr) {
                return setStr.split(',')
                    .map(item => item.trim())
                    .filter(item => item !== '')
                    .map(item => isNaN(item) ? item : Number(item));
            }
            
            function parseRelation(relationStr) {
                // Handle various input formats
                let pairs = [];
                
                // Try to split by various delimiters
                if (relationStr.includes('),(')) {
                    pairs = relationStr.split('),(')
                        .map(pair => pair.replace(/[()]/g, ''))
                        .filter(pair => pair !== '');
                } else if (relationStr.includes(') , (')) {
                    pairs = relationStr.split(') , (')
                        .map(pair => pair.replace(/[()]/g, ''))
                        .filter(pair => pair !== '');
                } else {
                    // Try to extract pairs using regex
                    const pairRegex = /\(([^,]+),([^)]+)\)/g;
                    let match;
                    while ((match = pairRegex.exec(relationStr)) !== null) {
                        pairs.push(`${match[1]},${match[2]}`);
                    }
                }
                
                return pairs.map(pair => {
                    const elements = pair.split(',');
                    if (elements.length !== 2) return null;
                    
                    const a = isNaN(elements[0]) ? elements[0].trim() : Number(elements[0]);
                    const b = isNaN(elements[1]) ? elements[1].trim() : Number(elements[1]);
                    
                    return [a, b];
                }).filter(pair => pair !== null);
            }
            
            function updateMatrix() {
                matrixContainer.innerHTML = '';
                
                if (currentSet.length === 0) return;
                
                // Create matrix grid
                const matrix = document.createElement('div');
                matrix.className = 'matrix';
                matrix.style.gridTemplateColumns = `40px repeat(${currentSet.length}, 40px)`;
                
                // Create header row
                const headerRow = document.createElement('div');
                headerRow.style.display = 'contents';
                
                const emptyCell = document.createElement('div');
                emptyCell.className = 'matrix-cell matrix-header';
                headerRow.appendChild(emptyCell);
                
                for (const element of currentSet) {
                    const headerCell = document.createElement('div');
                    headerCell.className = 'matrix-cell matrix-header';
                    headerCell.textContent = element;
                    headerRow.appendChild(headerCell);
                }
                
                matrix.appendChild(headerRow);
                
                // Create data rows
                for (let i = 0; i < currentSet.length; i++) {
                    const row = document.createElement('div');
                    row.style.display = 'contents';
                    
                    const rowHeader = document.createElement('div');
                    rowHeader.className = 'matrix-cell matrix-header';
                    rowHeader.textContent = currentSet[i];
                    row.appendChild(rowHeader);
                    
                    for (let j = 0; j < currentSet.length; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'matrix-cell';
                        cell.textContent = '0';
                        
                        // Check if this pair is in the relation
                        if (currentRelation.some(pair => 
                            pair[0] === currentSet[i] && pair[1] === currentSet[j])) {
                            cell.classList.add('active');
                            cell.textContent = '1';
                        }
                        
                        row.appendChild(cell);
                    }
                    
                    matrix.appendChild(row);
                }
                
                matrixContainer.appendChild(matrix);
            }
            
            function updateProperties() {
                const isReflexive = checkReflexive();
                const isIrreflexive = checkIrreflexive();
                const isSymmetric = checkSymmetric();
                const isAntisymmetric = checkAntisymmetric();
                const isAsymmetric = checkAsymmetric();
                const isTransitive = checkTransitive();
                const isEquivalence = isReflexive && isSymmetric && isTransitive;
                
                // Update property indicators
                updatePropertyIndicator(reflexiveEl, isReflexive);
                updatePropertyIndicator(irreflexiveEl, isIrreflexive);
                updatePropertyIndicator(symmetricEl, isSymmetric);
                updatePropertyIndicator(antisymmetricEl, isAntisymmetric);
                updatePropertyIndicator(asymmetricEl, isAsymmetric);
                updatePropertyIndicator(transitiveEl, isTransitive);
                updatePropertyIndicator(equivalenceEl, isEquivalence);
            }
            
            function updatePropertyIndicator(element, value) {
                const propertyName = element.querySelector('.property-name').textContent;
                const statusElement = element.querySelector('.property-status');
                
                element.className = 'property';
                if (value === true) {
                    element.classList.add('true');
                    statusElement.textContent = '✓ True';
                } else if (value === false) {
                    element.classList.add('false');
                    statusElement.textContent = '✗ False';
                } else {
                    element.classList.add('na');
                    statusElement.textContent = 'N/A';
                }
            }
            
            function checkReflexive() {
                for (const element of currentSet) {
                    if (!currentRelation.some(pair => pair[0] === element && pair[1] === element)) {
                        return false;
                    }
                }
                return true;
            }
            
            function checkIrreflexive() {
                for (const element of currentSet) {
                    if (currentRelation.some(pair => pair[0] === element && pair[1] === element)) {
                        return false;
                    }
                }
                return true;
            }
            
            function checkSymmetric() {
                for (const pair of currentRelation) {
                    if (!currentRelation.some(p => p[0] === pair[1] && p[1] === pair[0])) {
                        return false;
                    }
                }
                return true;
            }
            
            function checkAntisymmetric() {
                for (const pair of currentRelation) {
                    if (pair[0] !== pair[1] && 
                        currentRelation.some(p => p[0] === pair[1] && p[1] === pair[0])) {
                        return false;
                    }
                }
                return true;
            }
            
            function checkAsymmetric() {
                // A relation is asymmetric if it is both antisymmetric and irreflexive
                return checkAntisymmetric() && checkIrreflexive();
            }
            
            function checkTransitive() {
                for (const pair1 of currentRelation) {
                    for (const pair2 of currentRelation) {
                        if (pair1[1] === pair2[0]) {
                            if (!currentRelation.some(p => p[0] === pair1[0] && p[1] === pair2[1])) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            function updateGraph() {
                if (graphChart) {
                    graphChart.destroy();
                }
                
                const ctx = graphCanvas.getContext('2d');
                
                // Set canvas dimensions based on container
                const container = graphCanvas.parentElement;
                graphCanvas.width = container.clientWidth;
                graphCanvas.height = container.clientHeight;
                
                // Prepare nodes and edges for the graph
                const nodes = currentSet.map((element, index) => {
                    const angle = (2 * Math.PI * index) / currentSet.length;
                    const radius = Math.min(graphCanvas.width, graphCanvas.height) * 0.35;
                    return {
                        id: element,
                        x: graphCanvas.width / 2 + radius * Math.cos(angle),
                        y: graphCanvas.height / 2 + radius * Math.sin(angle)
                    };
                });
                
                const edges = currentRelation.map(pair => {
                    return {
                        from: pair[0],
                        to: pair[1]
                    };
                });
                
                // Draw the graph
                graphChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Relations',
                            data: nodes.map(node => ({x: node.x, y: node.y})),
                            backgroundColor: '#4a6fa5',
                            pointRadius: 15,
                            pointHoverRadius: 18
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `Element: ${nodes[context.dataIndex].id}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                display: false,
                                min: 0,
                                max: graphCanvas.width
                            },
                            y: {
                                display: false,
                                min: 0,
                                max: graphCanvas.height
                            }
                        },
                        animation: {
                            duration: 1000
                        }
                    }
                });
                
                // Manually draw edges (lines between points)
                setTimeout(() => {
                    // Draw edges
                    edges.forEach(edge => {
                        const fromNode = nodes.find(n => n.id === edge.from);
                        const toNode = nodes.find(n => n.id === edge.to);
                        
                        if (fromNode && toNode) {
                            ctx.beginPath();
                            ctx.moveTo(fromNode.x, fromNode.y);
                            ctx.lineTo(toNode.x, toNode.y);
                            
                            // Color code edges based on properties
                            if (edge.from === edge.to) {
                                ctx.strokeStyle = '#51cf66'; // Green for self-loops
                            } else if (currentRelation.some(p => p[0] === edge.to && p[1] === edge.from)) {
                                ctx.strokeStyle = '#ffd43b'; // Yellow for symmetric pairs
                            } else {
                                ctx.strokeStyle = '#4a6fa5'; // Blue for regular edges
                            }
                            
                            ctx.lineWidth = 3;
                            ctx.stroke();
                            
                            // Draw arrow for directed edge (if not self-loop)
                            if (edge.from !== edge.to) {
                                drawArrow(ctx, fromNode.x, fromNode.y, toNode.x, toNode.y);
                            } else {
                                // Draw self-loop
                                drawSelfLoop(ctx, fromNode.x, fromNode.y);
                            }
                        }
                    });
                    
                    // Redraw nodes on top
                    nodes.forEach(node => {
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, 15, 0, 2 * Math.PI);
                        ctx.fillStyle = '#4a6fa5';
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        
                        // Add labels
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(node.id, node.x, node.y);
                    });
                }, 500);
            }
            
            function drawArrow(ctx, fromX, fromY, toX, toY) {
                const headlen = 15;
                const angle = Math.atan2(toY - fromY, toX - fromX);
                
                // Calculate the actual end point (accounting for node radius)
                const dx = toX - fromX;
                const dy = toY - fromY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / dist;
                const unitY = dy / dist;
                
                const adjustedToX = toX - unitX * 15;
                const adjustedToY = toY - unitY * 15;
                
                // Starting point of the arrow (adjusted for node radius)
                const adjustedFromX = fromX + unitX * 15;
                const adjustedFromY = fromY + unitY * 15;
                
                ctx.beginPath();
                ctx.moveTo(adjustedFromX, adjustedFromY);
                ctx.lineTo(adjustedToX, adjustedToY);
                
                // Color code edges based on properties
                if (currentRelation.some(p => p[0] === toX && p[1] === fromX)) {
                    ctx.strokeStyle = '#ffd43b'; // Yellow for symmetric pairs
                } else {
                    ctx.strokeStyle = '#4a6fa5'; // Blue for regular edges
                }
                
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Arrowhead
                ctx.beginPath();
                ctx.moveTo(adjustedToX, adjustedToY);
                ctx.lineTo(
                    adjustedToX - headlen * Math.cos(angle - Math.PI / 6),
                    adjustedToY - headlen * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    adjustedToX - headlen * Math.cos(angle + Math.PI / 6),
                    adjustedToY - headlen * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fillStyle = ctx.strokeStyle;
                ctx.fill();
            }
            
            function drawSelfLoop(ctx, x, y) {
                ctx.beginPath();
                ctx.arc(x, y - 25, 20, 0, 2 * Math.PI);
                ctx.strokeStyle = '#51cf66';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Draw arrow on self-loop
                ctx.beginPath();
                ctx.moveTo(x + 15, y - 25);
                ctx.lineTo(x + 5, y - 35);
                ctx.lineTo(x + 5, y - 15);
                ctx.closePath();
                ctx.fillStyle = '#51cf66';
                ctx.fill();
            }
            
            function updateExplanation() {
                const isReflexive = checkReflexive();
                const isIrreflexive = checkIrreflexive();
                const isSymmetric = checkSymmetric();
                const isAntisymmetric = checkAntisymmetric();
                const isAsymmetric = checkAsymmetric();
                const isTransitive = checkTransitive();
                const isEquivalence = isReflexive && isSymmetric && isTransitive;
                
                let explanation = `<p><strong>Reflexive:</strong> ${isReflexive ? 'Yes' : 'No'}. `;
                explanation += isReflexive 
                    ? "Every element is related to itself." 
                    : "Not every element is related to itself.";
                
                explanation += `</p><p><strong>Irreflexive:</strong> ${isIrreflexive ? 'Yes' : 'No'}. `;
                explanation += isIrreflexive 
                    ? "No element is related to itself." 
                    : "At least one element is related to itself.";
                
                explanation += `</p><p><strong>Symmetric:</strong> ${isSymmetric ? 'Yes' : 'No'}. `;
                explanation += isSymmetric 
                    ? "If (a,b) is in the relation, then (b,a) is also in the relation." 
                    : "There exists (a,b) in the relation without (b,a).";
                
                explanation += `</p><p><strong>Antisymmetric:</strong> ${isAntisymmetric ? 'Yes' : 'No'}. `;
                explanation += isAntisymmetric 
                    ? "If (a,b) and (b,a) are both in the relation, then a must equal b." 
                    : "There exists distinct a and b with both (a,b) and (b,a) in the relation.";
                
                explanation += `</p><p><strong>Asymmetric:</strong> ${isAsymmetric ? 'Yes' : 'No'}. `;
                explanation += isAsymmetric 
                    ? "The relation is both antisymmetric and irreflexive." 
                    : "The relation is not both antisymmetric and irreflexive.";
                
                explanation += `</p><p><strong>Transitive:</strong> ${isTransitive ? 'Yes' : 'No'}. `;
                explanation += isTransitive 
                    ? "If (a,b) and (b,c) are in the relation, then (a,c) is also in the relation." 
                    : "There exists (a,b) and (b,c) in the relation without (a,c).";
                
                explanation += `</p><p><strong>Equivalence Relation:</strong> ${isEquivalence ? 'Yes' : 'No'}. `;
                explanation += isEquivalence 
                    ? "The relation is reflexive, symmetric, and transitive." 
                    : "The relation does not satisfy all three properties (reflexive, symmetric, transitive).";
                
                propertyExplanation.innerHTML = explanation;
            }
        });
    </script>
</body>
</html>
